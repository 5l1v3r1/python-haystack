Introduction:
=============

python-haystack is an heap analysis framework, focused on classic 
C structure matching.

The first class of algorithms gives the ability to search for known
structures in a live process's memory, or in a memory dump.

The second class of algorithms aims at giving a reverse engineering look
at a memory dump, focusing on reconstruction, classification of classic
C structures from memory. Heap analysis. Dynamic types definition.

How to get a memory dump:
=========================

While technically you could use a third party tool, we actually need 
memory mapping information to work with. So there is a dumping tool 
included :

$ sudo haystack-dump dump 26725 dumps/myssh.dump

You can easily reproduce the format of the dump, its a folder/archive 
containing each memory map in a separate file :
* content in a file named after it's start/end addresses ( 0x000700000-0x000800000 )
* 'mappings' file containing memory mappings metadata.  ( mappings )


Search for known structures:
============================

Prerequisite: sslsnoop for the definition of openssl/openssh structures.

Quick info: This tool demonstrate the ability to brute-force the search 
of a known structure, based on fields types assumptions. 

The magic is performed in the model.py module.

Command line example: 
---------------------

For example, this will dump the session_state structures + pointed 
children structures as an python object that we can play with.
Lets assume we have an ssh client or server as pid 4042.

$ sudo haystack --pid 4042 sslsnoop.ctypes_openssh.session_state search > instance.pickled
$ sudo haystack --pid 4042 sslsnoop.ctypes_openssh.session_state refresh 0xb8b70d18 > instance.pickled
$ sudo haystack --pid xxxx <your ctypes Structure> search > instance.pickled


Graphic example :
-----------------

There is also an attempt at a Graphical GUI ( Qt4 )
Dump the process, then you can open it in the GUI :

$ haystack-gui # ( and Ctrl-O , click click)
$ haystack-gui --dumpname dumps/myssh.dump


You can the search a structure into that memory mapping ( in [heap] for now ).
You have to import your extensions before that ( try sslsnoop.ctypes_openssh ) to have them listed in the search dialog.

Tip: As this is a beta version, sslsnoop is hard-imported in the GUI. You should have it installed.


python script interpreter example:
----------------------------------
>>> import haystack
>>> pid = 4042
>>> haystack.findStruct( pid , sslsnoop.ctypes_openssh.session_state)
>>> haystack.findStruct( pid , ctypes_example.big_struct)


Extensibility:
--------------

It's easy to add new structures. Its basically the ctypes definition of 
C structures that should be done following the next 4 steps :

a) Your class must extend haystack.model.LoadableMembers.
b) You must give your class a completed _fields_ (with one _ ), like all ctypes.Structure 
c) You can add an expectedValues dict() to your class to refine your search
d) call model.registerModule(sys.modules[__name__])

Easy 'creation' : 
  use h2xml and xml2py from ctypeslib
Advanced use : 
  You can override methods to fine tune some validation or loading 
  ( see sslsnoop for void pointers )

The global algorithm :

a)  The ctypes structure is mapped at the first offset of the memory mapping.
b)  The method loadMembers is called.
c)  The method isValid is called on self.
d) A validation test is done for each members, it's expected values and memory space validity (pointers) are tested.
    The validation does not recurse.
e)  Each members is then 'loaded' to local space. 
    If the value is a pointer or a model.LoadableMembers type, it's recursively Loaded. ( and validated).
    If the recursive loading fails, the calls fails. bye-bye.
f) Move to see next offset, goto a)


Heap analysis / Memory Reverser / Memory forensics:
===================================================

Quick info: This tool parse the heap for allocator structures, pointers
values, small integers and text (ascii/utf).
Given all the previous information, it can extract instances 
(future work wishes starting)
and helps you in classifying and defining structures types, based on 
signature algoritms.

Command line example:
--------------------
This will create several files in the folder containing <yourdumpname>.

$ python haystack-reverse <yourdumpname>

The most insteresting one being the <yourdumpname>_headers.py that
gives you an ctypes listing of all found structures, with gestimates
on fields types.

Other demo:
------------

$ python haystack-signature {show,sort} <yourdumpname>
$ python haystack/reverse/signature.py dumpname show --size 324 > test

This will resolve structures, create a signature, and group them by sig. 
Show only structs of size 324, grouped by similarities.
Work in progress.



Extension examples :
====================
@ see sslsnoop in the Pypi repo. openssl and nss structures are generated.
@ see ctypes-kernel on my github. Linux kernel structure are generated from a build kernel tree. (VMM is abitch)


Pseudo Example for extension :
==============================
from haystack.model import LoadableMembers, RangeValue, NotNull

class OpenSSLStruct(LoadableMembers):
  pass

class RSA(OpenSSLStruct):
  ''' rsa/rsa.h '''
  _fields_ = [
  ("pad",  ctypes.c_int), 
  ("version",  ctypes.c_long),
  ("meth",ctypes.POINTER(BIGNUM)),#const RSA_METHOD *meth;
  ("engine",ctypes.POINTER(ENGINE)),#ENGINE *engine;
  ('n', ctypes.POINTER(BIGNUM) ), ## still in ssh memap
  ('e', ctypes.POINTER(BIGNUM) ), ## still in ssh memap
  ('d', ctypes.POINTER(BIGNUM) ), ## still in ssh memap
  ('p', ctypes.POINTER(BIGNUM) ), ## still in ssh memap
  ('q', ctypes.POINTER(BIGNUM) ), ## still in ssh memap
  ('dmp1', ctypes.POINTER(BIGNUM) ),
  ('dmq1', ctypes.POINTER(BIGNUM) ),
  ('iqmp', ctypes.POINTER(BIGNUM) ),
  ("ex_data", CRYPTO_EX_DATA ),
  ("references", ctypes.c_int),
  ("flags", ctypes.c_int),
  ("_method_mod_n", ctypes.POINTER(BN_MONT_CTX) ),
  ("_method_mod_p", ctypes.POINTER(BN_MONT_CTX) ),
  ("_method_mod_q", ctypes.POINTER(BN_MONT_CTX) ),
  ("bignum_data",ctypes.POINTER(ctypes.c_ubyte)), ## moue c_char_p ou POINTER(c_char) ?
  ("blinding",ctypes.POINTER(BIGNUM)),#BN_BLINDING *blinding;
  ("mt_blinding",ctypes.POINTER(BIGNUM))#BN_BLINDING *mt_blinding;
  ]
  expectedValues={
    "pad": [0], 
    "version": [0], 
    "references": RangeValue(0,0xfff),
    "n": [NotNull],
    "e": [NotNull],
    "d": [NotNull],
    "p": [NotNull],
    "q": [NotNull],
    "dmp1": [NotNull],
    "dmq1": [NotNull],
    "iqmp": [NotNull]
  }
  def loadMembers(self, mappings, maxDepth):
    print 'example'
    if not LoadableMembers.loadMembers(self, mappings, maxDepth):
      log.debug('RSA not loaded')
      return False
    return True

# register to haystack
model.registerModule(sys.modules[__name__])

#EOF


not so FAQ :
============

What does it do ?:
------------------
The basic functionnality is to search in a process' memory maps for a 
specific C Structures.
The extended reverse engineering functionnality aims at reversing 
structures from memory/heap analysis.

How do it knows that the structures is valid ? :
------------------------------------------------
You add some constraints ( expectedValues ) on the fields. Pointers are also a good start.
 
Where does the idea comes from ? :
-----------------------------------
http://www.hsc.fr/ressources/breves/passe-partout.html.fr originally.
since I started in March 2011, I have uncovered several other related 
previous work.
Most of them are in the docs/ folder.
Other related work are mona.py from Immunity, some other Madiant stuff...
In a nutshell, this is probably not an original idea. But yet, I could 
not find a operational standalone lib for live memory extraction for sslsnoop, soo....


What are the dependencies ? :
----------------------------
python-ptrace on linux
winappdbg on win32
several others...
